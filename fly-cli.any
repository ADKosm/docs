#language anatomy

\title{The Fly CLI}{fly-cli}

The \code{fly} tool is a command line interface to Concourse. It is used for
a number of tasks from connecting to a shell in one of your build's
containers to uploading new pipeline configuration into a running Concourse.
Learning how to use \code{fly} will make using Concourse faster and more
useful.

You can download \code{fly} from a Concourse. There are download links for
common platforms in the bottom right hand corner of the main page.

Throughout this document we'll stick to the long-form name of every command and
flag. Once you've learned what the commands do, you may want to consult
\code{fly -h} to learn the short forms.

\section{Targeting your Concourse}{
  Fly works with an already deployed Concourse. If you don't already have one of
  these you should follow the \reference{getting-started}{Getting Started}
  guide to deploy a Concourse.

  Once you've deployed Concourse you can tell \code{fly} to target it via the
  \code{--target} flag. For example, if we wanted to run \code{fly sync} (don't
  worry what this means just yet) while pointing at Concourse that you normally
  reach by going to \code{http://ci.example.com} then you could run:

  \codeblock{bash}{
  $ fly --target 'http://ci.example.com' sync
  }

  \margin-note{
    The default Vagrant address is set as the default target in \code{fly}. This
    means that you don't need to do anything extra if you are using the Vagrant
    boxes to deploy Concourse.
  }

  The single quotes aren't always required, but if you need to put HTTP basic
  authentication credentials inline, then they can help by avoiding the need to
  escape special characters in passwords. For example:

  \codeblock{bash}{
  $ fly --target 'http://username:p@$$w0rd@ci.example.com' sync
  }

  If your Concourse uses SSL but does not have a CA signed certificate, you
  can use the \code{-k} or \code{--insecure} flag in order to make \code{fly}
  not check the remote certificates.

  For the rest of this document it is assumed you are setting the target in
  each of the commands and so it will not be included for brevity.
}

\section{\code{save-target}\aux{: Saving Concourse Targets}}{fly-save-target}{
  Using \code{save-target} allows you to save a named target to a \code{.flyrc}
  file stored in your home directory, so that you don't have to repeat the full
  URL for every command. Passing the name of a saved target via \code{--target}
  (or \code{-t} for short) will look up its details from your \code{.flyrc} and
  use them in the call specified.

  The \code{--api} flag and a target name are the only two properties required
  to save a target:

  \codeblock{bash}{
  $ fly save-target --name my-target --api https://example.com
  }

  The full set of properties can be specified as such:

  \codeblock{bash}{
  $ fly save-target --name my-target --api https://example.com --username my-user
  --password my-password
  }
}

\section{\code{sync}\aux{: Update your local copy of \code{fly}}}{fly-sync}{
  Occasionally we add additional features to \code{fly} or make changes to the
  communiction between it and Concourse's API server. To make sure you're
  running the latest and greatest version that works with the Concourse you
  are targeting we provide a command called \code{sync} that will update your
  local \code{fly}. It can be used like so:

  \codeblock{bash}{
  $ fly sync
  }

  If you see anything odd, for example the output of builds not rendering or
  certain commands throwing errors, be sure to run this command before
  investigating any further; it's pretty likely that something has changed with
  the API, especially while we're pre-1.0.
}

\section{\code{execute}\aux{: Submitting Local Tasks}}{fly-execute}{
  \omit-children-from-table-of-contents

  One of the most common use cases of \code{fly} is taking a local project on
  your computer and submitting it up with a task configuration to be run
  inside a container in Concourse. This is useful to build Linux projects on
  OS X or to avoid all of those debugging commits when something is configured
  differently between your local and remote setup.

  If you have a task configuration called \code{task.yml} that describes a
  task that only requires a single input, whose contents are in the current
  directory (e.g. most unit tests and simple integration tests) then you can
  just run:

  \codeblock{bash}{
  $ fly execute
  }

  Your files will be uploaded and the task will be executed with them. The
  working directory name will be used as the input name. If they do not match,
  you must specify \code{-i name=.} instead, where \code{name} is the input
  name from the task configuration.

  Fly will automatically capture \code{SIGINT} and \code{SIGTERM} and abort the
  build when received. This allows it to be transparently composed with other
  toolchains.

  If your task configuration is in a non-standard location then you can
  specify it using the \code{-c} or \code{--config} argument like so:

  \codeblock{bash}{
  $ fly execute --config tests.yml
  }

  If you have many extra files or large files in your currect directory that
  would normally be ignored by your version control system, then you can use
  the \code{-x} or \code{--exclude-ignored} flags in order to limit the files
  that you send to Concourse to just those that are not ignored.

  If your task needs to run as \code{root} then you can specify the \code{-p}
  or \code{--privileged} flag.

  \section{Providing multiple inputs}{
    Tasks in Concourse can take multiple inputs. Up until now we've just been
    submitting a single input (our current working directory) that has the same
    name as the directory.

    Tasks must specify the inputs that they require (for more information, refer
    to the \reference{configuring-tasks}{configuring tasks} documentation). For
    \code{fly} to upload these inputs you can use the \code{-i} or
    \code{--input} arguments with name and path pairs. For example:

    \codeblock{bash}{
    $ fly execute --input code=. --input stemcells=../stemcells
    }

    This would work together with a \code{task.yml} if its \code{inputs:}
    section was as follows:

    \codeblock{yaml}{
    inputs:
    - name: code
    - name: stemcells
    }

    If you specify an input then the default input will no longer be added
    automatically and you will need to explicitly list it (as with the
    \code{code} input above).

    This feature can be used to mimic other resources and try out combinations
    of input that would normally not be possible in a pipeline.
  }

  \section{Basing inputs on a job in your pipeline with \code{--inputs-from}}{
    If the \code{--inputs-from} flag is given, the specified job will be looked
    up in the pipeline, and the one-off build will base its inputs on those
    currently configured for the job.

    If any \code{--input} flags are given (see above), they will override the
    base set of inputs.

    For example:

    \codeblock{bash}{
    $ fly execute --config task.yml --inputs-from main/integration --input foo=./foo
    }

    This will trigger a one-off-build using the \code{task.yml} task
    config, basing its inputs on the latest candidates for the
    \code{integration} job in the \code{main} pipeline, with the \code{foo}
    input overridden to specify local code to run.

    This can be used to more closely replicate the state in CI when weeding out
    flakiness, or as a shortcut for local development so that you don't have to
    upload every single resource from your local machine.
  }

  \section{Providing values for \code{params}}{
    Any params listed in the task configuration can be specified by using
    environment variables.

    So, if you have a task with the following params:

    \codeblock{yaml}{
    params:
      FOO: fizzbuzz
      BAR:
    }

    ...and you run:

    \codeblock{bash}{
      BAR=hello fly execute
    }

    The task would then run with \code{BAR} as \code{"hello"}, and \code{FOO}
    as \code{"fizzbuzz"} (its default value).
  }
}

\section{\code{pipelines}\aux{: Listing configured pipelines}}{
  To list the currently-configured pipelines and their paused state, run:

  \codeblock{bash}{
  $ fly pipelines
  }
}

\section{\code{get-pipeline}\aux{: Fetching a pipeline's configuration}}{fly-get-pipeline}{
  Fly can be used to fetch and update the configuration for your pipelines. This
  is achieved by using the \reference{fly-get-pipeline} and
  \reference{fly-set-pipeline} commands. For example, to fetch the current
  configuration of your \code{my-pipeline} Concourse pipeline and print it on
  \code{STDOUT} run the following:

  \codeblock{bash}{
  $ fly get-pipeline --pipeline my-pipeline
  }

  To get JSON instead of YAML you can use the \code{-j} or \code{--json}
  argument. This can be useful when inspecting your config with
  \hyperlink{http://stedolan.github.io/jq/}{jq}.
}

\section{\code{set-pipeline}\aux{: Configuring Pipelines}}{fly-set-pipeline}{
  \omit-children-from-table-of-contents

  To submit a pipeline configuration to Concourse from a file on your local disk
  you can use the \code{-c} or \code{--config} flag, like so:

  \codeblock{bash}{
  $ fly set-pipeline --config pipeline.yml --pipeline my-pipeline
  }

  This will present a diff of the changes and ask you to confirm the changes.
  If you accept then Concourse's pipeline configuration will switch to the
  pipeline definition in the YAML file specified.

  Tip: you can use
  \hyperlink{https://en.wikipedia.org/wiki/Process_substitution}{process
  substitution} to quickly replicate a pipeline, potentially between Concourse
  instances, by composing \reference{get-pipeline} and \reference{set-pipeline}
  together like so:

  \codeblock{bash}{
  $ fly -t new set-pipeline -c <(fly -t old get-pipeline -p foo) -p foo
  }

  Note the use of the short flags, just to make it more obfuscated.

  \section{Using \code{\{\{parameters\}\}}}{parameters}{
    The pipeline configuration can contain template variable in the form of
    \code{\{\{foo-bar\}\}}. They will be replaced with string values populated
    by repeated \code{--var} or \code{--vars-from} flags.

    This allows for credentials to be extracted from a pipeline config, making it
    safe to check in to a public repository or pass around.

    For example, if you have a \code{pipeline.yml} as follows:

    \codeblock{yaml}{
    resources:
    - name: private-repo
      type: git
      source:
        uri: git@...
        branch: master
        private_key: \{\{private-repo-key\}\}
    }

    ...you could then configure this pipeline like so:

    \codeblock{bash}{
    $ fly configure --config pipeline.yml --var "private-repo-key=$(cat id_rsa)" my-pipeline
    }

    Or, if you had a \code{credentials.yml} as follows:

    \codeblock{yaml}{
    private-repo-key: |
      -----BEGIN RSA PRIVATE KEY-----
      ...
      -----END RSA PRIVATE KEY-----
    }

    ...you could configure it like so:

    \codeblock{bash}{
    $ fly configure --config pipeline.yml --vars-from credentials.yml my-pipeline
    }

    If both \code{--var} and \code{--vars-from} are specified, the \code{--var}
    flags take precedence.

    Note that only strings are supported for these values, so that
    interpolating them into the template is trivial. Other types of values, and
    features like concatenation, are not supported.
  }
}

\section{\code{destroy-pipeline}\aux{: Removing Pipelines}}{fly-destroy-pipeline}{
  Every now and then you just don't want a pipeline to be around anymore.
  Running \code{fly destroy-pipeline} will stop the pipeline activity and remove
  all data collected by the pipeline, including build history and collected
  versions.

  For example, to destroy the \code{my-pipeline} pipeline, you would run:

  \codeblock{bash}{
  $ fly destroy-pipeline --pipeline my-pipeline
  }
}

\section{\code{containers}\aux{: Listing active containers}}{
  To list the active containers across all your workers, run:

  \codeblock{bash}{
  $ fly containers
  }

  This can be useful when discovering the containers available for
  \reference{intercept}ing.
}

\section{\code{intercept}\aux{: Accessing a running or recent build's steps}}{fly-intercept}{
  Sometimes it's helpful to be on the same machine as your tasks so that you
  can profile or inspect them as they run or see the state the machine at the
  end of a run. Due to Concourse running tasks in containers on remote
  machines this would typically be hard to access.

  To this end, there is a \code{fly intercept} command that will give you an
  interactive shell inside the specified container. Containers are identified
  by a few things, so you may need to specify a few flags to hone down the
  results. If there are multiple containers that the flags could refer to, an
  interactive prompt will show up allowing you to disambiguate.

  \margin-note{
    The command \code{fly hijack} is an alias of \code{fly intercept}. Both can
    be used interchangably.
  }

  For example, running the following will run a task and then enter the
  finished task's container:

  \codeblock{bash}{
  $ fly execute
  $ fly intercept --step build
  }

  \margin-note{
    Be warned, if more than one person is using a Concourse server for running
    one-off builds then you may end up in a build that you did not expect!
  }

  Containers are around for a short time after a build finishes in order to
  allow people to intercept them.

  You can also intercept builds that were run in your pipeline. By using
  \code{--job}, \code{--build}, and \code{--step} you can intercept a specific
  step from a build of a job in your pipeline. These flags also have short
  forms, like so:

  \codeblock{bash}{
  $ fly intercept -j some-pipeline/some-job -b some-build -s some-step
  }

  Note that \code{--build} can be omitted, and will default to the most recent
  build of the job. One-off builds can be reached by passing in their build ID
  to \code{--build} which can be found on the build list page.

  The \code{--step} flag can also be omitted; this will let you pick the step
  interactively if you don't know the exact name.

  Resource checking containers can also be intercepted with \code{--check} or
  \code{-c}:

  \codeblock{bash}{
  $ fly intercept --check some-pipeline/some-resource
  }

  A specific command can also be given, e.g. \code{fly intercept ps auxf} or
  \code{fly intercept htop}. This allows for patterns such as \code{watch fly
  intercept ps auxf}, which will continuously show the process tree of the
  current build's task, even as the "current build" changes.
}

\section{\code{watch}\aux{: View logs of in-progress builds}}{fly-watch}{
  Concourse emits streaming colored logs on the website but it can be helpful
  to have the logs availiable to the command line. (e.g. so that they can be
  processed by other commands).

  The \code{watch} command can be used to do just this. You can also view
  builds that are running in your pipeline, or builds that have already
  finished.

  Note that unlike \reference{fly-execute}, killing \code{fly watch} via
  \code{SIGINT} or \code{SIGTERM} will \italic{not} abort the build.

  To watch the most recent one-off build, just run \code{fly watch} with no
  arugments. To watch a specific build (one-off or no), pass \code{--build}
  with the ID of the build to watch. This ID is available at the start of
  \reference{fly-execute}'s output or by browsing to the builds list in the web
  UI.

  By using the \code{--job} and \code{--build} flags you can pick out a
  specific build of a job to watch. For example, the following command will
  either show the archived logs for an old build if it has finished running or
  it will stream the current logs if the build is still in progress.

  \codeblock{bash}{
  $ fly watch --job my-pipeline/tests --build 52
  }

  If the \code{--job} flag is specified and \code{--build} is omitted, the most
  recent build of the specified job will be selected.
}

\section{\code{workers}\aux{: Listing registered workers}}{
  To list the currently registered workers, including additional metadata, run:

  \codeblock{bash}{
  $ fly workers
  }

  This can be useful for monitoring the status of your workers, if you suspect
  that one keeps dropping out of the pool or getting tasked with too many
  containers, etc.
}

\section{\code{checklist}\aux{: Generate Checkman definition files}}{fly-checklist}{
  \hyperlink{https://github.com/cppforlife/checkman}{Checkman} supports
  retrieving build status from Concourse. If you would like to set this up
  yourself then there is documentation in the
  \hyperlink{https://github.com/cppforlife/checkman#included-check-scripts}{Checkman
  README} about the syntax required. However, \code{fly} can generate the
  Checkman files based on your pipelines using the command below.

  \codeblock{bash}{
  $ fly checklist --pipeline my-pipeline > ~/Checkman/my-pipeline
  }
}
